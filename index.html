<!DOCTYPE html>
<html lang="en">

<head>
  <title>JavaScript in the Wild</title>
</head>

<body>
  <h1>JavaScript in the Wild</h1>
  <p>Please load this file in VSCode and Chrome, and open the Console in Chrome Dev Tools.</p>
  <p>Work through the challenges found inside the script tag in this document,
    until the Console reports all tests passing.</p>

  <script>
    // In CHALLENGES 1-7, you will fill in some functions.

    // To do this, translate each üß† set of instructions into a working function.
    // ‚ùó Functions are already scaffolded as arrow functions.
    // ‚ùó You must add the parameters to the function that you need
    // ‚ùó Watch the Guided Project to learn proper debugging technique.

    // üëâ CHALLENGE 1
    // üß† The function swapper takes an array and swaps its first and last elements.
    // üß† If the array has fewer than two elements the function returns the string "No swap performed".
    // üß† Examples of usage:
    // swapper(['a', 'b']) // should return ['b', 'a']
    // swapper(['a', 'b', 'c']) // should return ['c', 'b', 'a']
    // swapper(['a']) // should return "No swap performed"
    // ‚ùó Notes
    // üß† Try using destructuring to grab a reference to the first element of the array
    // üß† Try using the at method of arrays to grab the last element
    const swapper = (array) => {
      if (array.length < 2) {
        return 'No swap performed';
      }

      var [sub_array_index_0] = array;
      var last = array[array.length - 1];

      array[0] = last;
      array[array.length - 1] = sub_array_index_0;

      return array;
    }

    // üëâ CHALLENGE 2
    // üß† The function headAndTail takes an array as its argument.
    // üß† It returns a new array with two elements.
    // üß† The first element is the head of the original array.
    // üß† The second element is the tail of the original array.
    // üß† If the given array is empty, return the string "This array is empty"
    // üß† Examples of usage:
    // headAndTail([1, 2, 3]) // should return [1, [2, 3]]
    // ‚ùó Notes
    // üß† Try using destructuring and the spread operator to get the head and tail.
    // üß† Try using the ternary operator instead of a conditional statement when deciding what to return.
    // üß† So instead of doing `if ('foo') return 'bar' else return 'baz'` do `return 'foo' ? 'bar' : 'baz'`
    // üß† The above recommendations allow to write the whole function body in just two clean lines!
    const headAndTail = (array) => {
      var [, ...sub_array] = array;
      return array.length > 0 ? [array[0], [...sub_array]] : 'This array is empty';
    }

    // üëâ CHALLENGE 3
    // üß† The function devGreet takes an isFrontend Boolean, and an isHappy Boolean, as arguments.
    // üß† Examples of usage:
    // devGreet(true, true) // should return "Hey, I am a frontend dev and I am happy"
    // devGreet(true, false) // should return "Hey, I am a frontend dev and I am sad"
    // devGreet(false, true) // should return "Hey, I am a backend dev and I am happy"
    // devGreet(false, false) // should return "Hey, I am a backend dev and I am sad"
    // ‚ùó Notes
    // üß† Use ternary expressions to construct the string.
    const devGreet = (isFrontend, isHappy) => {
      let type;
      let emotion;
      isFrontend ? type = 'frontend' : type = 'backend';
      isHappy ? emotion = 'happy' : emotion = 'sad';

      return `Hey, I am a ${type} dev and I am ${emotion}`;
    }

    // üëâ CHALLENGE 4
    // üß† The function recognize takes an object representing a user.
    // üß† If the object has a name property, return a string in the format "<name> Rules!".
    // üß† If there is no name prop, return the string "Hidden Person Rocks!"
    // üß† Examples of usage:
    // recognize({ name: 'Katherine Johnson' }) // should return "Katherine Johnson Rules!"
    // recognize({}) // should return "Hidden Person Rocks!"
    // ‚ùó Notes
    // üß† Try using destructuring to grab the name, and a return followed by a ternary expression.
    const recognize = (user_object) => {
      let {name} = user_object;
      return name ? `${name} Rules!` : "Hidden Person Rocks!";
    }

    // üëâ CHALLENGE 5
    // üß† The function processBooleans takes an array of Booleans represented using integers (1/0 instead of true/false)
    // üß† It should return a new array containing strings ("Y"/"N")
    // üß† Example of usage:
    // processBooleans([1, 0, 0, 1, 0]) // should return ["Y", "N", "N", "Y", "N"]
    // ‚ùó Notes
    // üß† Using map, arrow function syntax, and the ternary, you can make this function a short one-liner
    const processBooleans = (bool_array) => {
      var new_array = bool_array.map((bool) => {return bool ? "Y" : "N"}); 
      return new_array;
    }

    // üëâ CHALLENGE 6
    // üß† The function reverseString takes a string as its argument, and returns it reversed.
    // üß† If the string is a palindrome though, return the string "It's a palindrome!"
    // üß† Examples of usage:
    // reverseString('Hello, World') // should return "dlroW ,olleH"
    // ‚ùó Notes
    // üß† Research on your own what a palindrome is.
    // üß† Split the string but do not use the reverse method of arrays. Let's do it manually.
    // üß† We suggest using a for loop. Research how to loop backwards over an array, starting at the last element.
    // üß† Use a ternary in the return statement.
    const reverseString = (string) => {
      let split_string = string.split('');

      let new_string = [];

      for (i = string.length - 1; i >= 0; i--) {
        new_string.push(split_string[i])
      }

      final_string = new_string.join('');

      return final_string === string ? "It's a palindrome!" : final_string; 
    }

    // üëâ CHALLENGE 7
    // üß† The function zip receives three arrays as arguments. The three arrays are of the same length (which could be any length).
    // üß† Array 1 contains names, array 2 contains year numbers, and array 3 contains Booleans.
    // üß† The zip function returns an array of objects
    // üß† Each object inside the returned array is constructed combining the information from arrays 1, 2, 3.
    // üß† Each object has three props: `name`, `born` and `jsLover`.
    // üß† Examples of usage:
    // zip(['Joe', 'Anna'], [1987, 1955], [true, false])
    //   should return [{ name: 'Joe', born: '1987', jsLover: true }, { name: 'Anna', born: 1955, jsLover: false }]
    // ‚ùó Notes
    // üß† Even though object properties have no particular order, to avoid confusing
    // the test runner, please set in each object first name, then age, and finally jsLover.
    const zip = (array1, array2, array3) => {
      let names = [...array1];
      let born = [...array2];
      let jsLover = [...array3];

      class person {
        constructor(name, born, jsLover) {
          this.name = name; 
          this.born = born;
          this.jsLover = jsLover;
        }
      }

      let final_obj_array = [];
      let new_person = {}

      for (i = 0; i < array1.length; i++) {
        new_person = new person(array1[i], array2[i], array3[i]);
        final_obj_array.push(new_person);
      }

      return final_obj_array;
    }

    // üß™ TESTS, do not work below this line
    // üß™ TESTS, do not work below this line
    // üß™ TESTS, do not work below this line
    runTests('CHALLENGE 1 - swapper', swapper, [
      [[['a', 'b']], ['b', 'a']],
      [[['a', 'b', 'c']], ['c', 'b', 'a']],
      [[['a', 'b', 'c', 'd']], ['d', 'b', 'c', 'a']],
      [[['a']], "No swap performed"],
      [[[]], "No swap performed"],
    ])
    runTests('CHALLENGE 2 - headAndTail', headAndTail, [
      [[['a', 'b']], ['a', ['b']]],
      [[['a', 'b', 'c']], ['a', ['b', 'c']]],
      [[['a', 'b', 'c', 'd']], ['a', ['b', 'c', 'd']]],
      [[['a']], ['a', []]],
      [[[]], "This array is empty"],
    ])
    runTests('CHALLENGE 3 - devGreet', devGreet, [
      [[true, true], "Hey, I am a frontend dev and I am happy"],
      [[true, false], "Hey, I am a frontend dev and I am sad"],
      [[false, true], "Hey, I am a backend dev and I am happy"],
      [[false, false], "Hey, I am a backend dev and I am sad"],
    ])
    runTests('CHALLENGE 4 - recognize', recognize, [
      [[{ name: 'Katherine Johnson' }], "Katherine Johnson Rules!"],
      [[{ name: 'Gertrude Elion', born: 1918 }], "Gertrude Elion Rules!"],
      [[{ nobelPrize: 1986 }], "Hidden Person Rocks!"],
    ])
    runTests('CHALLENGE 5 - processBooleans', processBooleans, [
      [[[1, 0, 0, 1, 0, 1]], ["Y", "N", "N", "Y", "N", "Y"]],
      [[[0, 1, 0, 1, 1]], ["N", "Y", "N", "Y", "Y"]],
      [[[]], []],
    ])
    runTests('CHALLENGE 6 - reverseString', reverseString, [
      [['Hello, World'], 'dlroW ,olleH'],
      [['Personal Access Token'], 'nekoT sseccA lanosreP'],
      [['tesla'], 'alset'],
      [['rotator'], "It's a palindrome!"],
      [['tenet'], "It's a palindrome!"],
      [['axa'], "It's a palindrome!"],
    ])
    const unzipped1 = [['Alla', 'Josh', 'Byron'], [1995, 1988, 1996], [true, true, false]]
    const zipped1 = [
      { name: 'Alla', born: 1995, jsLover: true },
      { name: 'Josh', born: 1988, jsLover: true },
      { name: 'Byron', born: 1996, jsLover: false },
    ]
    const unzipped2 = [['Joe', 'Anna'], [1987, 1955], [true, false]]
    const zipped2 = [
      { name: 'Joe', born: 1987, jsLover: true },
      { name: 'Anna', born: 1955, jsLover: false },
    ]
    runTests('CHALLENGE 7 - zip', zip, [
      [unzipped1, zipped1],
      [unzipped2, zipped2],
    ])
    function runTests(testName, func, tests) {
      let results = []
      tests.forEach(test => {
        const argsList = test[0]
        const expected = JSON.stringify(test[1])
        const actual = JSON.stringify(func.apply(null, JSON.parse(JSON.stringify(argsList))))
        results.push([argsList, expected, actual])
      })
      console.log('\n' + testName)
      if (results.every(result => result[1] === result[2])) console.log('\t‚úÖ All tests pass')
      else results.forEach((result, idx) => {
        if (result[1] === result[2]) console.log(`\t‚úÖ Test ${idx + 1} passes`)
        else console.log(`\t‚ùå Test ${idx + 1} fails: ${func.name}(${result[0]
          .map(JSON.stringify)}) should return ${result[1]} but returns ${result[2]}`)
      })
    }
  </script>
</body>

</html>
